// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"io"
	"net/url"
	"os"
	"sync"

	resource "github.com/concourse/github-release-resource"
	"github.com/google/go-github/v66/github"
)

type FakeGitHub struct {
	CreateReleaseStub        func(github.RepositoryRelease) (*github.RepositoryRelease, error)
	createReleaseMutex       sync.RWMutex
	createReleaseArgsForCall []struct {
		arg1 github.RepositoryRelease
	}
	createReleaseReturns struct {
		result1 *github.RepositoryRelease
		result2 error
	}
	createReleaseReturnsOnCall map[int]struct {
		result1 *github.RepositoryRelease
		result2 error
	}
	DeleteReleaseAssetStub        func(github.ReleaseAsset) error
	deleteReleaseAssetMutex       sync.RWMutex
	deleteReleaseAssetArgsForCall []struct {
		arg1 github.ReleaseAsset
	}
	deleteReleaseAssetReturns struct {
		result1 error
	}
	deleteReleaseAssetReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadReleaseAssetStub        func(github.ReleaseAsset) (io.ReadCloser, error)
	downloadReleaseAssetMutex       sync.RWMutex
	downloadReleaseAssetArgsForCall []struct {
		arg1 github.ReleaseAsset
	}
	downloadReleaseAssetReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	downloadReleaseAssetReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	GetReleaseStub        func(int) (*github.RepositoryRelease, error)
	getReleaseMutex       sync.RWMutex
	getReleaseArgsForCall []struct {
		arg1 int
	}
	getReleaseReturns struct {
		result1 *github.RepositoryRelease
		result2 error
	}
	getReleaseReturnsOnCall map[int]struct {
		result1 *github.RepositoryRelease
		result2 error
	}
	GetReleaseByTagStub        func(string) (*github.RepositoryRelease, error)
	getReleaseByTagMutex       sync.RWMutex
	getReleaseByTagArgsForCall []struct {
		arg1 string
	}
	getReleaseByTagReturns struct {
		result1 *github.RepositoryRelease
		result2 error
	}
	getReleaseByTagReturnsOnCall map[int]struct {
		result1 *github.RepositoryRelease
		result2 error
	}
	GetTarballLinkStub        func(string) (*url.URL, error)
	getTarballLinkMutex       sync.RWMutex
	getTarballLinkArgsForCall []struct {
		arg1 string
	}
	getTarballLinkReturns struct {
		result1 *url.URL
		result2 error
	}
	getTarballLinkReturnsOnCall map[int]struct {
		result1 *url.URL
		result2 error
	}
	GetZipballLinkStub        func(string) (*url.URL, error)
	getZipballLinkMutex       sync.RWMutex
	getZipballLinkArgsForCall []struct {
		arg1 string
	}
	getZipballLinkReturns struct {
		result1 *url.URL
		result2 error
	}
	getZipballLinkReturnsOnCall map[int]struct {
		result1 *url.URL
		result2 error
	}
	ListReleaseAssetsStub        func(github.RepositoryRelease) ([]*github.ReleaseAsset, error)
	listReleaseAssetsMutex       sync.RWMutex
	listReleaseAssetsArgsForCall []struct {
		arg1 github.RepositoryRelease
	}
	listReleaseAssetsReturns struct {
		result1 []*github.ReleaseAsset
		result2 error
	}
	listReleaseAssetsReturnsOnCall map[int]struct {
		result1 []*github.ReleaseAsset
		result2 error
	}
	ListReleasesStub        func() ([]*github.RepositoryRelease, error)
	listReleasesMutex       sync.RWMutex
	listReleasesArgsForCall []struct {
	}
	listReleasesReturns struct {
		result1 []*github.RepositoryRelease
		result2 error
	}
	listReleasesReturnsOnCall map[int]struct {
		result1 []*github.RepositoryRelease
		result2 error
	}
	ResolveTagToCommitSHAStub        func(string) (string, error)
	resolveTagToCommitSHAMutex       sync.RWMutex
	resolveTagToCommitSHAArgsForCall []struct {
		arg1 string
	}
	resolveTagToCommitSHAReturns struct {
		result1 string
		result2 error
	}
	resolveTagToCommitSHAReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	UpdateReleaseStub        func(github.RepositoryRelease) (*github.RepositoryRelease, error)
	updateReleaseMutex       sync.RWMutex
	updateReleaseArgsForCall []struct {
		arg1 github.RepositoryRelease
	}
	updateReleaseReturns struct {
		result1 *github.RepositoryRelease
		result2 error
	}
	updateReleaseReturnsOnCall map[int]struct {
		result1 *github.RepositoryRelease
		result2 error
	}
	UploadReleaseAssetStub        func(github.RepositoryRelease, string, *os.File) error
	uploadReleaseAssetMutex       sync.RWMutex
	uploadReleaseAssetArgsForCall []struct {
		arg1 github.RepositoryRelease
		arg2 string
		arg3 *os.File
	}
	uploadReleaseAssetReturns struct {
		result1 error
	}
	uploadReleaseAssetReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGitHub) CreateRelease(arg1 github.RepositoryRelease) (*github.RepositoryRelease, error) {
	fake.createReleaseMutex.Lock()
	ret, specificReturn := fake.createReleaseReturnsOnCall[len(fake.createReleaseArgsForCall)]
	fake.createReleaseArgsForCall = append(fake.createReleaseArgsForCall, struct {
		arg1 github.RepositoryRelease
	}{arg1})
	stub := fake.CreateReleaseStub
	fakeReturns := fake.createReleaseReturns
	fake.recordInvocation("CreateRelease", []interface{}{arg1})
	fake.createReleaseMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitHub) CreateReleaseCallCount() int {
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	return len(fake.createReleaseArgsForCall)
}

func (fake *FakeGitHub) CreateReleaseCalls(stub func(github.RepositoryRelease) (*github.RepositoryRelease, error)) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = stub
}

func (fake *FakeGitHub) CreateReleaseArgsForCall(i int) github.RepositoryRelease {
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	argsForCall := fake.createReleaseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitHub) CreateReleaseReturns(result1 *github.RepositoryRelease, result2 error) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = nil
	fake.createReleaseReturns = struct {
		result1 *github.RepositoryRelease
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) CreateReleaseReturnsOnCall(i int, result1 *github.RepositoryRelease, result2 error) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = nil
	if fake.createReleaseReturnsOnCall == nil {
		fake.createReleaseReturnsOnCall = make(map[int]struct {
			result1 *github.RepositoryRelease
			result2 error
		})
	}
	fake.createReleaseReturnsOnCall[i] = struct {
		result1 *github.RepositoryRelease
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) DeleteReleaseAsset(arg1 github.ReleaseAsset) error {
	fake.deleteReleaseAssetMutex.Lock()
	ret, specificReturn := fake.deleteReleaseAssetReturnsOnCall[len(fake.deleteReleaseAssetArgsForCall)]
	fake.deleteReleaseAssetArgsForCall = append(fake.deleteReleaseAssetArgsForCall, struct {
		arg1 github.ReleaseAsset
	}{arg1})
	stub := fake.DeleteReleaseAssetStub
	fakeReturns := fake.deleteReleaseAssetReturns
	fake.recordInvocation("DeleteReleaseAsset", []interface{}{arg1})
	fake.deleteReleaseAssetMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitHub) DeleteReleaseAssetCallCount() int {
	fake.deleteReleaseAssetMutex.RLock()
	defer fake.deleteReleaseAssetMutex.RUnlock()
	return len(fake.deleteReleaseAssetArgsForCall)
}

func (fake *FakeGitHub) DeleteReleaseAssetCalls(stub func(github.ReleaseAsset) error) {
	fake.deleteReleaseAssetMutex.Lock()
	defer fake.deleteReleaseAssetMutex.Unlock()
	fake.DeleteReleaseAssetStub = stub
}

func (fake *FakeGitHub) DeleteReleaseAssetArgsForCall(i int) github.ReleaseAsset {
	fake.deleteReleaseAssetMutex.RLock()
	defer fake.deleteReleaseAssetMutex.RUnlock()
	argsForCall := fake.deleteReleaseAssetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitHub) DeleteReleaseAssetReturns(result1 error) {
	fake.deleteReleaseAssetMutex.Lock()
	defer fake.deleteReleaseAssetMutex.Unlock()
	fake.DeleteReleaseAssetStub = nil
	fake.deleteReleaseAssetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitHub) DeleteReleaseAssetReturnsOnCall(i int, result1 error) {
	fake.deleteReleaseAssetMutex.Lock()
	defer fake.deleteReleaseAssetMutex.Unlock()
	fake.DeleteReleaseAssetStub = nil
	if fake.deleteReleaseAssetReturnsOnCall == nil {
		fake.deleteReleaseAssetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReleaseAssetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitHub) DownloadReleaseAsset(arg1 github.ReleaseAsset) (io.ReadCloser, error) {
	fake.downloadReleaseAssetMutex.Lock()
	ret, specificReturn := fake.downloadReleaseAssetReturnsOnCall[len(fake.downloadReleaseAssetArgsForCall)]
	fake.downloadReleaseAssetArgsForCall = append(fake.downloadReleaseAssetArgsForCall, struct {
		arg1 github.ReleaseAsset
	}{arg1})
	stub := fake.DownloadReleaseAssetStub
	fakeReturns := fake.downloadReleaseAssetReturns
	fake.recordInvocation("DownloadReleaseAsset", []interface{}{arg1})
	fake.downloadReleaseAssetMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitHub) DownloadReleaseAssetCallCount() int {
	fake.downloadReleaseAssetMutex.RLock()
	defer fake.downloadReleaseAssetMutex.RUnlock()
	return len(fake.downloadReleaseAssetArgsForCall)
}

func (fake *FakeGitHub) DownloadReleaseAssetCalls(stub func(github.ReleaseAsset) (io.ReadCloser, error)) {
	fake.downloadReleaseAssetMutex.Lock()
	defer fake.downloadReleaseAssetMutex.Unlock()
	fake.DownloadReleaseAssetStub = stub
}

func (fake *FakeGitHub) DownloadReleaseAssetArgsForCall(i int) github.ReleaseAsset {
	fake.downloadReleaseAssetMutex.RLock()
	defer fake.downloadReleaseAssetMutex.RUnlock()
	argsForCall := fake.downloadReleaseAssetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitHub) DownloadReleaseAssetReturns(result1 io.ReadCloser, result2 error) {
	fake.downloadReleaseAssetMutex.Lock()
	defer fake.downloadReleaseAssetMutex.Unlock()
	fake.DownloadReleaseAssetStub = nil
	fake.downloadReleaseAssetReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) DownloadReleaseAssetReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.downloadReleaseAssetMutex.Lock()
	defer fake.downloadReleaseAssetMutex.Unlock()
	fake.DownloadReleaseAssetStub = nil
	if fake.downloadReleaseAssetReturnsOnCall == nil {
		fake.downloadReleaseAssetReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.downloadReleaseAssetReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) GetRelease(arg1 int) (*github.RepositoryRelease, error) {
	fake.getReleaseMutex.Lock()
	ret, specificReturn := fake.getReleaseReturnsOnCall[len(fake.getReleaseArgsForCall)]
	fake.getReleaseArgsForCall = append(fake.getReleaseArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetReleaseStub
	fakeReturns := fake.getReleaseReturns
	fake.recordInvocation("GetRelease", []interface{}{arg1})
	fake.getReleaseMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitHub) GetReleaseCallCount() int {
	fake.getReleaseMutex.RLock()
	defer fake.getReleaseMutex.RUnlock()
	return len(fake.getReleaseArgsForCall)
}

func (fake *FakeGitHub) GetReleaseCalls(stub func(int) (*github.RepositoryRelease, error)) {
	fake.getReleaseMutex.Lock()
	defer fake.getReleaseMutex.Unlock()
	fake.GetReleaseStub = stub
}

func (fake *FakeGitHub) GetReleaseArgsForCall(i int) int {
	fake.getReleaseMutex.RLock()
	defer fake.getReleaseMutex.RUnlock()
	argsForCall := fake.getReleaseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitHub) GetReleaseReturns(result1 *github.RepositoryRelease, result2 error) {
	fake.getReleaseMutex.Lock()
	defer fake.getReleaseMutex.Unlock()
	fake.GetReleaseStub = nil
	fake.getReleaseReturns = struct {
		result1 *github.RepositoryRelease
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) GetReleaseReturnsOnCall(i int, result1 *github.RepositoryRelease, result2 error) {
	fake.getReleaseMutex.Lock()
	defer fake.getReleaseMutex.Unlock()
	fake.GetReleaseStub = nil
	if fake.getReleaseReturnsOnCall == nil {
		fake.getReleaseReturnsOnCall = make(map[int]struct {
			result1 *github.RepositoryRelease
			result2 error
		})
	}
	fake.getReleaseReturnsOnCall[i] = struct {
		result1 *github.RepositoryRelease
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) GetReleaseByTag(arg1 string) (*github.RepositoryRelease, error) {
	fake.getReleaseByTagMutex.Lock()
	ret, specificReturn := fake.getReleaseByTagReturnsOnCall[len(fake.getReleaseByTagArgsForCall)]
	fake.getReleaseByTagArgsForCall = append(fake.getReleaseByTagArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetReleaseByTagStub
	fakeReturns := fake.getReleaseByTagReturns
	fake.recordInvocation("GetReleaseByTag", []interface{}{arg1})
	fake.getReleaseByTagMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitHub) GetReleaseByTagCallCount() int {
	fake.getReleaseByTagMutex.RLock()
	defer fake.getReleaseByTagMutex.RUnlock()
	return len(fake.getReleaseByTagArgsForCall)
}

func (fake *FakeGitHub) GetReleaseByTagCalls(stub func(string) (*github.RepositoryRelease, error)) {
	fake.getReleaseByTagMutex.Lock()
	defer fake.getReleaseByTagMutex.Unlock()
	fake.GetReleaseByTagStub = stub
}

func (fake *FakeGitHub) GetReleaseByTagArgsForCall(i int) string {
	fake.getReleaseByTagMutex.RLock()
	defer fake.getReleaseByTagMutex.RUnlock()
	argsForCall := fake.getReleaseByTagArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitHub) GetReleaseByTagReturns(result1 *github.RepositoryRelease, result2 error) {
	fake.getReleaseByTagMutex.Lock()
	defer fake.getReleaseByTagMutex.Unlock()
	fake.GetReleaseByTagStub = nil
	fake.getReleaseByTagReturns = struct {
		result1 *github.RepositoryRelease
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) GetReleaseByTagReturnsOnCall(i int, result1 *github.RepositoryRelease, result2 error) {
	fake.getReleaseByTagMutex.Lock()
	defer fake.getReleaseByTagMutex.Unlock()
	fake.GetReleaseByTagStub = nil
	if fake.getReleaseByTagReturnsOnCall == nil {
		fake.getReleaseByTagReturnsOnCall = make(map[int]struct {
			result1 *github.RepositoryRelease
			result2 error
		})
	}
	fake.getReleaseByTagReturnsOnCall[i] = struct {
		result1 *github.RepositoryRelease
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) GetTarballLink(arg1 string) (*url.URL, error) {
	fake.getTarballLinkMutex.Lock()
	ret, specificReturn := fake.getTarballLinkReturnsOnCall[len(fake.getTarballLinkArgsForCall)]
	fake.getTarballLinkArgsForCall = append(fake.getTarballLinkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTarballLinkStub
	fakeReturns := fake.getTarballLinkReturns
	fake.recordInvocation("GetTarballLink", []interface{}{arg1})
	fake.getTarballLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitHub) GetTarballLinkCallCount() int {
	fake.getTarballLinkMutex.RLock()
	defer fake.getTarballLinkMutex.RUnlock()
	return len(fake.getTarballLinkArgsForCall)
}

func (fake *FakeGitHub) GetTarballLinkCalls(stub func(string) (*url.URL, error)) {
	fake.getTarballLinkMutex.Lock()
	defer fake.getTarballLinkMutex.Unlock()
	fake.GetTarballLinkStub = stub
}

func (fake *FakeGitHub) GetTarballLinkArgsForCall(i int) string {
	fake.getTarballLinkMutex.RLock()
	defer fake.getTarballLinkMutex.RUnlock()
	argsForCall := fake.getTarballLinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitHub) GetTarballLinkReturns(result1 *url.URL, result2 error) {
	fake.getTarballLinkMutex.Lock()
	defer fake.getTarballLinkMutex.Unlock()
	fake.GetTarballLinkStub = nil
	fake.getTarballLinkReturns = struct {
		result1 *url.URL
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) GetTarballLinkReturnsOnCall(i int, result1 *url.URL, result2 error) {
	fake.getTarballLinkMutex.Lock()
	defer fake.getTarballLinkMutex.Unlock()
	fake.GetTarballLinkStub = nil
	if fake.getTarballLinkReturnsOnCall == nil {
		fake.getTarballLinkReturnsOnCall = make(map[int]struct {
			result1 *url.URL
			result2 error
		})
	}
	fake.getTarballLinkReturnsOnCall[i] = struct {
		result1 *url.URL
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) GetZipballLink(arg1 string) (*url.URL, error) {
	fake.getZipballLinkMutex.Lock()
	ret, specificReturn := fake.getZipballLinkReturnsOnCall[len(fake.getZipballLinkArgsForCall)]
	fake.getZipballLinkArgsForCall = append(fake.getZipballLinkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetZipballLinkStub
	fakeReturns := fake.getZipballLinkReturns
	fake.recordInvocation("GetZipballLink", []interface{}{arg1})
	fake.getZipballLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitHub) GetZipballLinkCallCount() int {
	fake.getZipballLinkMutex.RLock()
	defer fake.getZipballLinkMutex.RUnlock()
	return len(fake.getZipballLinkArgsForCall)
}

func (fake *FakeGitHub) GetZipballLinkCalls(stub func(string) (*url.URL, error)) {
	fake.getZipballLinkMutex.Lock()
	defer fake.getZipballLinkMutex.Unlock()
	fake.GetZipballLinkStub = stub
}

func (fake *FakeGitHub) GetZipballLinkArgsForCall(i int) string {
	fake.getZipballLinkMutex.RLock()
	defer fake.getZipballLinkMutex.RUnlock()
	argsForCall := fake.getZipballLinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitHub) GetZipballLinkReturns(result1 *url.URL, result2 error) {
	fake.getZipballLinkMutex.Lock()
	defer fake.getZipballLinkMutex.Unlock()
	fake.GetZipballLinkStub = nil
	fake.getZipballLinkReturns = struct {
		result1 *url.URL
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) GetZipballLinkReturnsOnCall(i int, result1 *url.URL, result2 error) {
	fake.getZipballLinkMutex.Lock()
	defer fake.getZipballLinkMutex.Unlock()
	fake.GetZipballLinkStub = nil
	if fake.getZipballLinkReturnsOnCall == nil {
		fake.getZipballLinkReturnsOnCall = make(map[int]struct {
			result1 *url.URL
			result2 error
		})
	}
	fake.getZipballLinkReturnsOnCall[i] = struct {
		result1 *url.URL
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) ListReleaseAssets(arg1 github.RepositoryRelease) ([]*github.ReleaseAsset, error) {
	fake.listReleaseAssetsMutex.Lock()
	ret, specificReturn := fake.listReleaseAssetsReturnsOnCall[len(fake.listReleaseAssetsArgsForCall)]
	fake.listReleaseAssetsArgsForCall = append(fake.listReleaseAssetsArgsForCall, struct {
		arg1 github.RepositoryRelease
	}{arg1})
	stub := fake.ListReleaseAssetsStub
	fakeReturns := fake.listReleaseAssetsReturns
	fake.recordInvocation("ListReleaseAssets", []interface{}{arg1})
	fake.listReleaseAssetsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitHub) ListReleaseAssetsCallCount() int {
	fake.listReleaseAssetsMutex.RLock()
	defer fake.listReleaseAssetsMutex.RUnlock()
	return len(fake.listReleaseAssetsArgsForCall)
}

func (fake *FakeGitHub) ListReleaseAssetsCalls(stub func(github.RepositoryRelease) ([]*github.ReleaseAsset, error)) {
	fake.listReleaseAssetsMutex.Lock()
	defer fake.listReleaseAssetsMutex.Unlock()
	fake.ListReleaseAssetsStub = stub
}

func (fake *FakeGitHub) ListReleaseAssetsArgsForCall(i int) github.RepositoryRelease {
	fake.listReleaseAssetsMutex.RLock()
	defer fake.listReleaseAssetsMutex.RUnlock()
	argsForCall := fake.listReleaseAssetsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitHub) ListReleaseAssetsReturns(result1 []*github.ReleaseAsset, result2 error) {
	fake.listReleaseAssetsMutex.Lock()
	defer fake.listReleaseAssetsMutex.Unlock()
	fake.ListReleaseAssetsStub = nil
	fake.listReleaseAssetsReturns = struct {
		result1 []*github.ReleaseAsset
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) ListReleaseAssetsReturnsOnCall(i int, result1 []*github.ReleaseAsset, result2 error) {
	fake.listReleaseAssetsMutex.Lock()
	defer fake.listReleaseAssetsMutex.Unlock()
	fake.ListReleaseAssetsStub = nil
	if fake.listReleaseAssetsReturnsOnCall == nil {
		fake.listReleaseAssetsReturnsOnCall = make(map[int]struct {
			result1 []*github.ReleaseAsset
			result2 error
		})
	}
	fake.listReleaseAssetsReturnsOnCall[i] = struct {
		result1 []*github.ReleaseAsset
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) ListReleases() ([]*github.RepositoryRelease, error) {
	fake.listReleasesMutex.Lock()
	ret, specificReturn := fake.listReleasesReturnsOnCall[len(fake.listReleasesArgsForCall)]
	fake.listReleasesArgsForCall = append(fake.listReleasesArgsForCall, struct {
	}{})
	stub := fake.ListReleasesStub
	fakeReturns := fake.listReleasesReturns
	fake.recordInvocation("ListReleases", []interface{}{})
	fake.listReleasesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitHub) ListReleasesCallCount() int {
	fake.listReleasesMutex.RLock()
	defer fake.listReleasesMutex.RUnlock()
	return len(fake.listReleasesArgsForCall)
}

func (fake *FakeGitHub) ListReleasesCalls(stub func() ([]*github.RepositoryRelease, error)) {
	fake.listReleasesMutex.Lock()
	defer fake.listReleasesMutex.Unlock()
	fake.ListReleasesStub = stub
}

func (fake *FakeGitHub) ListReleasesReturns(result1 []*github.RepositoryRelease, result2 error) {
	fake.listReleasesMutex.Lock()
	defer fake.listReleasesMutex.Unlock()
	fake.ListReleasesStub = nil
	fake.listReleasesReturns = struct {
		result1 []*github.RepositoryRelease
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) ListReleasesReturnsOnCall(i int, result1 []*github.RepositoryRelease, result2 error) {
	fake.listReleasesMutex.Lock()
	defer fake.listReleasesMutex.Unlock()
	fake.ListReleasesStub = nil
	if fake.listReleasesReturnsOnCall == nil {
		fake.listReleasesReturnsOnCall = make(map[int]struct {
			result1 []*github.RepositoryRelease
			result2 error
		})
	}
	fake.listReleasesReturnsOnCall[i] = struct {
		result1 []*github.RepositoryRelease
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) ResolveTagToCommitSHA(arg1 string) (string, error) {
	fake.resolveTagToCommitSHAMutex.Lock()
	ret, specificReturn := fake.resolveTagToCommitSHAReturnsOnCall[len(fake.resolveTagToCommitSHAArgsForCall)]
	fake.resolveTagToCommitSHAArgsForCall = append(fake.resolveTagToCommitSHAArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ResolveTagToCommitSHAStub
	fakeReturns := fake.resolveTagToCommitSHAReturns
	fake.recordInvocation("ResolveTagToCommitSHA", []interface{}{arg1})
	fake.resolveTagToCommitSHAMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitHub) ResolveTagToCommitSHACallCount() int {
	fake.resolveTagToCommitSHAMutex.RLock()
	defer fake.resolveTagToCommitSHAMutex.RUnlock()
	return len(fake.resolveTagToCommitSHAArgsForCall)
}

func (fake *FakeGitHub) ResolveTagToCommitSHACalls(stub func(string) (string, error)) {
	fake.resolveTagToCommitSHAMutex.Lock()
	defer fake.resolveTagToCommitSHAMutex.Unlock()
	fake.ResolveTagToCommitSHAStub = stub
}

func (fake *FakeGitHub) ResolveTagToCommitSHAArgsForCall(i int) string {
	fake.resolveTagToCommitSHAMutex.RLock()
	defer fake.resolveTagToCommitSHAMutex.RUnlock()
	argsForCall := fake.resolveTagToCommitSHAArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitHub) ResolveTagToCommitSHAReturns(result1 string, result2 error) {
	fake.resolveTagToCommitSHAMutex.Lock()
	defer fake.resolveTagToCommitSHAMutex.Unlock()
	fake.ResolveTagToCommitSHAStub = nil
	fake.resolveTagToCommitSHAReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) ResolveTagToCommitSHAReturnsOnCall(i int, result1 string, result2 error) {
	fake.resolveTagToCommitSHAMutex.Lock()
	defer fake.resolveTagToCommitSHAMutex.Unlock()
	fake.ResolveTagToCommitSHAStub = nil
	if fake.resolveTagToCommitSHAReturnsOnCall == nil {
		fake.resolveTagToCommitSHAReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.resolveTagToCommitSHAReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) UpdateRelease(arg1 github.RepositoryRelease) (*github.RepositoryRelease, error) {
	fake.updateReleaseMutex.Lock()
	ret, specificReturn := fake.updateReleaseReturnsOnCall[len(fake.updateReleaseArgsForCall)]
	fake.updateReleaseArgsForCall = append(fake.updateReleaseArgsForCall, struct {
		arg1 github.RepositoryRelease
	}{arg1})
	stub := fake.UpdateReleaseStub
	fakeReturns := fake.updateReleaseReturns
	fake.recordInvocation("UpdateRelease", []interface{}{arg1})
	fake.updateReleaseMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitHub) UpdateReleaseCallCount() int {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	return len(fake.updateReleaseArgsForCall)
}

func (fake *FakeGitHub) UpdateReleaseCalls(stub func(github.RepositoryRelease) (*github.RepositoryRelease, error)) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = stub
}

func (fake *FakeGitHub) UpdateReleaseArgsForCall(i int) github.RepositoryRelease {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	argsForCall := fake.updateReleaseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitHub) UpdateReleaseReturns(result1 *github.RepositoryRelease, result2 error) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = nil
	fake.updateReleaseReturns = struct {
		result1 *github.RepositoryRelease
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) UpdateReleaseReturnsOnCall(i int, result1 *github.RepositoryRelease, result2 error) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = nil
	if fake.updateReleaseReturnsOnCall == nil {
		fake.updateReleaseReturnsOnCall = make(map[int]struct {
			result1 *github.RepositoryRelease
			result2 error
		})
	}
	fake.updateReleaseReturnsOnCall[i] = struct {
		result1 *github.RepositoryRelease
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHub) UploadReleaseAsset(arg1 github.RepositoryRelease, arg2 string, arg3 *os.File) error {
	fake.uploadReleaseAssetMutex.Lock()
	ret, specificReturn := fake.uploadReleaseAssetReturnsOnCall[len(fake.uploadReleaseAssetArgsForCall)]
	fake.uploadReleaseAssetArgsForCall = append(fake.uploadReleaseAssetArgsForCall, struct {
		arg1 github.RepositoryRelease
		arg2 string
		arg3 *os.File
	}{arg1, arg2, arg3})
	stub := fake.UploadReleaseAssetStub
	fakeReturns := fake.uploadReleaseAssetReturns
	fake.recordInvocation("UploadReleaseAsset", []interface{}{arg1, arg2, arg3})
	fake.uploadReleaseAssetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitHub) UploadReleaseAssetCallCount() int {
	fake.uploadReleaseAssetMutex.RLock()
	defer fake.uploadReleaseAssetMutex.RUnlock()
	return len(fake.uploadReleaseAssetArgsForCall)
}

func (fake *FakeGitHub) UploadReleaseAssetCalls(stub func(github.RepositoryRelease, string, *os.File) error) {
	fake.uploadReleaseAssetMutex.Lock()
	defer fake.uploadReleaseAssetMutex.Unlock()
	fake.UploadReleaseAssetStub = stub
}

func (fake *FakeGitHub) UploadReleaseAssetArgsForCall(i int) (github.RepositoryRelease, string, *os.File) {
	fake.uploadReleaseAssetMutex.RLock()
	defer fake.uploadReleaseAssetMutex.RUnlock()
	argsForCall := fake.uploadReleaseAssetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGitHub) UploadReleaseAssetReturns(result1 error) {
	fake.uploadReleaseAssetMutex.Lock()
	defer fake.uploadReleaseAssetMutex.Unlock()
	fake.UploadReleaseAssetStub = nil
	fake.uploadReleaseAssetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitHub) UploadReleaseAssetReturnsOnCall(i int, result1 error) {
	fake.uploadReleaseAssetMutex.Lock()
	defer fake.uploadReleaseAssetMutex.Unlock()
	fake.UploadReleaseAssetStub = nil
	if fake.uploadReleaseAssetReturnsOnCall == nil {
		fake.uploadReleaseAssetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadReleaseAssetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitHub) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	fake.deleteReleaseAssetMutex.RLock()
	defer fake.deleteReleaseAssetMutex.RUnlock()
	fake.downloadReleaseAssetMutex.RLock()
	defer fake.downloadReleaseAssetMutex.RUnlock()
	fake.getReleaseMutex.RLock()
	defer fake.getReleaseMutex.RUnlock()
	fake.getReleaseByTagMutex.RLock()
	defer fake.getReleaseByTagMutex.RUnlock()
	fake.getTarballLinkMutex.RLock()
	defer fake.getTarballLinkMutex.RUnlock()
	fake.getZipballLinkMutex.RLock()
	defer fake.getZipballLinkMutex.RUnlock()
	fake.listReleaseAssetsMutex.RLock()
	defer fake.listReleaseAssetsMutex.RUnlock()
	fake.listReleasesMutex.RLock()
	defer fake.listReleasesMutex.RUnlock()
	fake.resolveTagToCommitSHAMutex.RLock()
	defer fake.resolveTagToCommitSHAMutex.RUnlock()
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	fake.uploadReleaseAssetMutex.RLock()
	defer fake.uploadReleaseAssetMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGitHub) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ resource.GitHub = new(FakeGitHub)
